<!DOCTYPE html>
<html>
  <head>
    <title>
      Seminar Web Engineering in Winter semester 2024/2025 - REST API Design
    </title>
    <link rel="stylesheet" type="text/css" href="main.css" />
    <link
      href="http://fonts.googleapis.com/css?family=Source+Serif+Pro:400,600,700"
      rel="stylesheet"
      type="text/css"
    />
    <link
      href="http://fonts.googleapis.com/css?family=Inconsolata:400,700"
      rel="stylesheet"
      type="text/css"
    />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  </head>
  <body>
    <header>
      <h2>Seminar Web Engineering in Winter semester 2024/2025</h2>
      <h1>REST API Design</h1>
      <h2 class="author">Georgiy Sinokhchyan</h2>
      <h2 class="author">Quoc Khanh Le</h2>
      <h2 class="Advisor">Advisor: Christoph Göpfert</h2>
      <h3 class="affiliation">
        Master Web Engineering<br />
        Technische Universität Chemnitz<br />
        Chemnitz, Deutschland
      </h3>
    </header>
    <section>
      <h2>1. Introduction</h2>
      <p class="credit">(Georgiy Sinokhchyan)</p>
      <p>
        Over the last two decades, REST (Representational State Transfer) has emerged as a pivotal 
        architectural style for designing web services, largely due to its simplicity, scalability, 
        and flexibility. Introduced by Roy Fielding in his dissertation in 2000 <a href="#r1">[1]</a>, REST has since 
        become the backbone of modern web services, enabling seamless interaction between distributed 
        systems. As the digital ecosystem grows with increasing reliance on mobile devices, microservices,
        and distributed applications, REST APIs have proven to be a reliable framework for managing 
        client-server communications.
      </p>
      <p>
        The flexibility of REST APIs stems from its principles of statelessness, 
        uniform interfaces, and support for hypermedia. These principles, combined with practical 
        design guidelines like those outlined in Masse's REST API Design Rulebook <a href="#r2">[2]</a>, 
        provide developers with the tools to create scalable, secure, and evolvable APIs. However, 
        designing robust REST APIs involves more than adherence to principles—it requires careful 
        consideration of best practices, patterns, and emerging challenges in fields like the semantic web and 
        data security.
      </p>
      <p>
        As REST APIs have become a cornerstone of software engineering, their impact extends beyond traditional 
        web services <a href="#r1">[1]</a>. They enable seamless integration across heterogeneous systems, supporting the 
        interoperability required for IoT devices, machine learning workflows, and cloud-based 
        services <a href="#r2">[2]</a>. Furthermore, the adoption of REST APIs as a standard has led to the proliferation of 
        developer-friendly tools and frameworks, streamlining the implementation process and reducing 
        development time <a href="#r2">[2]</a>.
      </p>
      <p>
        Despite their widespread adoption, REST APIs face evolving challenges. The growing complexity of 
        distributed architectures introduces concerns related to performance optimization, security 
        vulnerabilities, and compliance with global data protection standards <a href="#r3">[3]</a>. Addressing these issues 
        demands a deeper focus on implementing advanced mechanisms, such as caching, rate limiting, and 
        API gateways, to maintain efficiency and ensure reliable operations <a href="#r3">[3]</a>. Additionally, the emergence 
        of alternative architectural styles, such as GraphQL and gRPC, presents competitive options that 
        challenge REST to continuously evolve and adapt to modern requirements.
      </p>
    </section>
    <section>
      <h2>2. REST API Constraints</h2>
      <h3>2.1 Client-Server</h3>
      <p class="credit">(Georgiy Sinokhchyan)</p>
      <p>
        The client-server paradigm remains a foundational principle of REST architecture, ensuring robust 
        modularity and scalability by clearly delineating responsibilities between clients and servers <a href="#r1">[1]</a>. 
        This separation of concerns allows the user interface (client) to remain distinct from the 
        data storage and processing layers (server), which fosters flexibility and simplifies the design 
        of both components. This architectural choice enhances adaptability, allowing either the client or 
        the server to undergo updates or reengineering without disrupting the functionality or compatibility 
        of the system as a whole <a href="#r2">[2]</a>.
      </p>
      <p>
        One of the critical advantages of this model is its ability to facilitate independent evolution. 
        By decoupling the two entities, REST enables continuous development and integration of new 
        technologies or features without necessitating simultaneous changes on both ends. This isolation 
        also allows developers to optimize performance and functionality independently, maximizing the 
        efficiency of the overall system <a href="#r2">[2]</a>.
      </p>
      <p>
        Furthermore, the client-server paradigm enhances scalability, allowing servers to handle multiple 
        client requests simultaneously, even under heavy workloads <a href="#r3">[3]</a>. Centralizing processing and data 
        management on the server side not only simplifies client architecture but also reinforces security.
        This model supports the implementation of consistent, centralized security protocols, which are easier 
        to maintain and enforce, particularly in distributed environments. Additionally, the modular 
        design reduces the risk of data breaches or unauthorized access by minimizing exposure points 
        and providing better control over sensitive information <a href="#r5">[5]</a>.
      </p>
      <p>
        In conclusion, the client-server model, as employed in REST architecture, creates a stable, 
        efficient, and scalable framework that accommodates the evolving demands of modern web services <a href="#r1">[1]</a>.
        By adhering to this paradigm, REST APIs achieve a high level of reliability and resilience, 
        making them an indispensable tool in the development of distributed systems<a href="#r2">[2]</a>.
      </p>
    </section>
    <section>
      <h3>2.2 Stateless</h3>
      <p class="credit">(Georgiy Sinokhchyan)</p>
      <p>
        Statelessness is a cornerstone of the REST architectural style, mandating that each client 
        request carries all the necessary information required for its processing, without reliance 
        on any previously stored server state <a href="#r1">[1]</a>. By removing the necessity to maintain session state 
        on the server, this approach not only simplifies server-side logic but also significantly enhances 
        the scalability of distributed systems. Servers can process requests independently, without requiring 
        contextual data from prior interactions, leading to streamlined operations and reduced overhead <a href="#r1">[1]</a>.
      </p>
      <p>
        However, implementing statelessness introduces its own set of challenges. 
        The absence of persistent session information requires developers to design each request carefully, 
        ensuring it contains adequate metadata for proper processing. For example, incorporating secure 
        session tokens or other identifiers is critical for handling authentication and maintaining security, 
        aligning with industry best practices such as those outlined by OWASP <a href="#r6">[6]</a>. This additional complexity 
        places a greater burden on client-side implementation and data transmission but is essential for 
        ensuring stateless integrity.
      </p>
      <p>
        The benefits of statelessness extend far beyond operational simplicity. 
        Fault tolerance is greatly enhanced, as servers are not dependent on session continuity and can 
        recover from failures without risking data loss or inconsistency <a href="#r1">[1]</a>. Furthermore, the ability 
        to distribute the load evenly across server clusters supports scalability, particularly 
        in high-traffic environments <a href="#r6">[6]</a>. Stateless systems also facilitate straightforward maintenance 
        and debugging processes, as their design inherently minimizes interdependencies, making them 
        easier to update, optimize, and secure over time.
      </p>
    </section>
    <section>
      <h3>2.3 Cache</h3>
      <p class="credit">(Georgiy Sinokhchyan)</p>
      <p>
        Caching serves as a vital optimization technique in RESTful systems, aimed at improving performance, 
        reducing latency, and alleviating server load. By temporarily storing server responses, caching 
        enables faster access to frequently requested resources, significantly minimizing redundant 
        interactions with the server <a href="#r1">[1]</a>. This approach not only optimizes resource utilization 
        but also enhances the overall efficiency of distributed systems.
      </p>
      <p>
        In alignment with REST principles, caching relies on a set of well-defined mechanisms to ensure 
        consistency and reliability. The use of unique URIs for resource identification allows cached 
        responses to be accurately linked to specific resources <a href="#r1">[1]</a>. This ensures that cached data remains 
        relevant and correctly associated. Furthermore, caching is typically applied to GET requests, 
        as these are inherently idempotent and do not modify resource states. This restriction preserves 
        the consistency and predictability of cached content while adhering to REST constraints <a href="#r3">[3]</a>.
      </p>
      <p>
        Metadata plays a critical role in defining caching behavior. HTTP headers such as Cache-Control, 
        ETag, and Expires specify how, when, and for how long a resource can be cached. These self-descriptive
        messages allow clients and intermediaries to determine the validity and freshness of cached responses, 
        thereby preventing the use of stale or invalid data. This level of control ensures that cached 
        content remains an asset rather than a liability in system performance <a href="#r2">[2]</a>.
      </p>    
      <p>
        Effective implementation of caching offers several significant benefits. It reduces the frequency 
        of server interactions, thereby decreasing the computational and network overhead on the backend <a href="#r1">[1]</a>. 
        Additionally, it improves user experience by reducing latency, as cached resources can be delivered 
        faster than real-time server responses <a href="#3">[3]</a>. Moreover, caching contributes to system scalability by 
        distributing the load more efficiently across servers and clients <a href="#r5">[5]</a>. These advantages underscore the 
        importance of caching as a cornerstone in the design of reliable, high-performance web systems.
      </p>    
      <p>
        By leveraging caching in compliance with REST principles, developers can optimize system performance 
        while maintaining consistency and reliability. This makes caching an indispensable element in 
        building robust, scalable, and efficient RESTful architectures.
      </p>    
    </section>
    <section>
      <h3>2.4 Uniform Interface</h3>
      <p class="credit">(Quoc Khanh Le)</p>
      <p>
        Uniform interface is the major constraint that sets the REST API
        architectural style apart from other network-based API styles
        <a href="#r1">[1]</a>. It requires that the outward-facing interface of
        a service remains standardized, promoting independence between the
        interface and the implementation of a service <a href="#r1">[1]</a>.
        This independence allows for decoupled evolvability, but has the
        drawback of introducing loss of efficiency because the information
        transferred needs to be in a general, standardized format and not one
        optimized for the application's needs <a href="#r1">[1]</a>. To satisfy 
        the uniform interface constraint, four sub-constraints need to be 
        fulfilled: identification of resources, manipulation of resources through 
        representations, self-descriptive messages, and hypermedia as the engine 
        of application state <a href="#r1">[1]</a>.
      </p>
      <p>
        The resources mentioned are defined by Roy Fielding <a href="#r1">[1]</a> as "any
        information that can be named": a document/ an image, a time-dependent
        service, a collection of other resources, an object, etc. A resource, in
        this sense, is a pointer to a set of entities, and not any specific
        entity at any point in time <a href="#r1">[1]</a>.
      </p>
      <h4>2.4.1 Identification of Resources</h4>
      <p class="credit">(Quoc Khanh Le)</p>
      <p>
        A resource identifier uniquely identifies a resource in an interaction
        between components and can be used in combination with REST connectors
        to manipulate the value of the resource, regardless of the backing
        implementation of this manipulation <a href="#r1">[1]</a>.
      </p>
      <h4>2.4.2 Manipulation of Resources Through Representations</h4>
      <p class="credit">(Quoc Khanh Le)</p>
      <p>
        The manipulation of a resource is done through a representation, which
        is a byte sequence and the metadata that describes those bytes
        <a href="#r1">[1]</a>. The representation represents the contemporary or
        targeted state of a resource when being transferred between components
        <a href="#r1">[1]</a>
      </p>
      <h4>2.4.3 Self-Descriptive Messages</h4>
      <p class="credit">(Quoc Khanh Le)</p>
      <p>
        The self-descriptive messages constraint requires that no states are
        transferred between requests, in other words, the messages should
        contain all of the required information to process it, including the
        semantics indicated through media types and standard methods,
        cacheability communicated in responses
        <a href="#r1">[1]</a>.
      </p>
      <h4>2.4.4 Hypermedia as The Engine of Application State (HATEOAS)</h4>
      <p class="credit">(Quoc Khanh Le)</p>
      <p>
        The core idea of HATEOAS is that the client does not need to have prior
        knowledge of the API's structure to interact with it. To achieve this,
        the responses need to contain links to other resources that guide the
        client to other actions based on the current application state.
      </p>
    </section>
    <section>
      <h3>2.5 Layered System</h3>
      <p class="credit">(Quoc Khanh Le)</p>
      <p>
        The layered system constraint requires the components to only know of
        their immediate neighboring components, which promotes inter-layer
        independence and allows layers to be added to or removed from the
        architecture without greatly affecting the existing infrastructure
        <a href="#r1">[1]</a>.
      </p>
      <p>
        This constraint enables the use of firewalls, load balancing and caching
        components to improve the security, scalability and performance of the
        system <a href="#r1">[1]</a>. It also allows layers to act as
        intermediaries between legacy clients or services and newer components
        or clients <a href="#r1">[1]</a>.
      </p>
      <p>
        However, the addition of layers can induce a general increase in latency
        and overhead in the request-response chains
        <a href="#r1">[1]</a>.
      </p>
    </section>
    <section>
      <h3>2.6 Code-On-Demand</h3>
      <p class="credit">(Quoc Khanh Le)</p>
      <p>
        The code-on-demand constraint allows the server to send executable code
        to the clients, effectively enabling the extension of client
        functionality after deployment <a href="#r1">[1]</a>. This capability,
        nonetheless, reduces the visibility of the interaction, as it can be
        challenging for an inspector to fully understand all of the effects that
        executing the code sent from the server will have <a href="#r1">[1]</a>.
      </p>
      <p>
        This constraint is the only optional constraint in REST because APIs
        following the REST architectural style can choose to implement it or not
        (or to restrict its availability to a range of clients) and therefore
        only reap the benefits and suffer the drawbacks accordingly
        <a href="#r1">[1]</a>.
      </p>
    </section>
    <section>
      <h2>3. Design Patterns and Best Practices</h2>
      <p class="credit">(Quoc Khanh Le)</p>
      <h3>3.1 Versioning</h3>
      <p>
        Whether or not one should version their REST APIs is still a heavily
        debated topic in the developer community as of today
        <a href="#r10">[10]</a>. Some sources, such as <a href="#r3">[3]</a>,
        argue that REST APIs don't need versioning thanks to hypermedia. Roy
        Fielding also agreed with this sentiment, claiming versioning to be an
        anti-customer practice <a href="#r4">[4]</a>.
      </p>
      <p>
        B. Mulloy <a href="#r5">[5]</a>, on the other hand, believes that
        developers should "never release an API without a version and make the
        version mandatory". He also recommends prefixing every version with a
        "v", moving it to the leftmost of the URL path (e.g. /v2/books) and
        maintaining at least one version back <a href="#r5">[5]</a>.
      </p>
    </section>
    <section>
      <h3>3.2 Description of Resources</h3>
      <p>
        Nouns should be used for resource names <a href="#r3">[3]</a>,
        <a href="#r5">[5]</a>, as they represent resources to be accessed and
        manipulated, rather than actions to be performed. In the
        context of HTTP APIs, intentions of the clients should be indicated by 
        the HTTP verbs, not embedded in the URLs themselves <a href="#r5">[5]</a>.
      </p>
      <p>
        Additionally, to ensure consistency and predictability, it's important to avoid 
        mixing plural and singular forms when naming resources <a href="#r3">[3]</a>.
      </p>
      <p>
        Adhering to JavaScript naming conventions is also recommended
        <a href="#r5">[5]</a> since JSON is currently the most used data format
        for transferring data between clients and servers <a href="#r3">[3]</a>.
      </p>
      <p>
        Finally, the names of resources should be specific to aid client developers in API
        comprehension and utilization <a href="#r5">[5]</a>. For example,
        descriptive endpoints such as /blogs, /videos, /news, etc. are
        preferable to generic ones such as /items <a href="#r5">[5]</a>.
      </p>
    </section>
    <section>
      <h3>3.3 Identification of Resources</h3>
      <p>
        URI should be self-explanatory to the best of its ability
        <a href="#r5">[5]</a>. For every resource, there should be generally 2
        base URLs: one for accessing/manipulating the list and the other for
        accessing/manipulating a specific item in the list (for example, /books
        and /books/393) <a href="#r5">[5]</a>.
      </p>
      <p>
        On top of that, if there are no security measures in place, the URIs should 
        avoid directly referencing the resources
        <a href="#r3">[3]</a>, <a href="#r6">[6]</a>.
      </p>
    </section>
    <section>
      <h3>3.4 Error Handling</h3>
      <p>
        The number of HTTP status codes produced by the API should be limited to
        eight or fewer to reduce client developers' cognitive load and allow them
        to focus on the implementation of functionalities
        <a href="#r5">[5]</a>. The use of HTTP status codes also should align
        with the guidelines outlined in the HTTP specification
        <a href="#r7">[7]</a>, <a href="#r8">[8]</a>.
      </p>
      <p>
        Furthermore, error messages returned from the API should be verbose
        <a href="#r5">[5]</a>. B. Mulloy <a href="#r5">[5]</a> recommends
        returning a message for the developer detailing how to fix the error, a
        user-friendly message to be displayed, an application error code for
        code handling and a link for further explanation of the error. For
        example, the following response can be returned when a device with an
        invalid device ID is requested by a client:
      </p>
      <pre>
  {
    "developerMessage" : "The device requested cannot be found, please
      make sure the device ID is correct and the user is authorized to
      access it.", 
    "userMessage":"Device not found", 
    "errorCode" : "device-not-found", 
    "moreInfo": "http://example.com/errors/device-not-found"
  }</pre
      >
    </section>
    <section>
      <h3>3.5 Parameter Usage</h3>
      <p>
        Parameters should be used for filtering, sorting, selecting and paging
        of resources <a href="#r3">[3]</a>. Followed are some examples:
      </p>
      <pre>

  <b>Filtering:</b> GET /devices?filter=(type=key-pad)

  <b>Sorting:</b> GET /devices?sort=type

  <b>Selecting:</b> GET /devices?fields=id,name,type,status

  <b>Paging:</b> GET /devices?offset=20&limit=10
  </pre
      >
    </section>
    <section>
      <h3>3.6 Interaction With Resources</h3>
      <p>
        HTTP methods should conform with their semantics as defined by the HTTP
        specification <a href="#r5">[5]</a>, <a href="#r8">[8]</a>. Generally,
        POST, GET, PUT, and DELETE should be used to perform the CRUD actions
        (Create, Read, Update, Delete, in that respective order)
        <a href="#r8">[8]</a>.
      </p>
      <p>
        For any resource, if the list of methods allowed is not provided
        to the consumers, the HTTP OPTIONS verb should be supported 
        <a href="#r3">[3]</a>. This helps avoid the scenario where
        a client attempts to use an unsupported verb, resulting in the transmission 
        of unnecessary data <a href="#r3">[3]</a>.
      </p>
      <p>
        Moreover, to leverage caching, conditional GET should be implemented
        <a href="#r7">[7]</a>. HTTP has two built-in mechanisms for this purpose:
        the two header pairs "Last-Modified"/"If-Modified-Since" and
        "Etag"/"If-None-Match", with the latter avoiding the "one-second window"
        change problem of the former <a href="#r7">[7]</a>. More specifically, due to
        the one-second granularity of the "If-Modified-Since" header, when two
        changes occur within one second, the clients that have cached the first
        representation will not be able to detect the second change <a href="#r7">[7]</a>.
      </p>
    </section>
    <section>
      <h3>3.7 Support Mime Types</h3>
      <p>
        B. Mulloy <a href="#r5">[5]</a> suggests that at least 2 MIME types
        should be supported, particularly when the server is receiving data. Among them, the
        default representation format should be JSON because it's more universal
        and less verbose than XML <a href="#r5">[5]</a>.
      </p>
      <p>
        To accommodate hypermedia, it is recommended to use existing MIME types such 
        as Collection+JSON or HAL+XML <a href="#r3">[3]</a>.
      </p>
      <p>
        The API should also support content negotiation, typically through the
        use of the HTTP header "Accept" to indicate the MIME types and,
        optionally, their preference or weight
        <a href="#r3">[3]</a>.
      </p>
    </section>
    <section>
      <h2>4. REST APIs in Semantic Web Domain</h2>
      <p class="credit">(Georgiy Sinokhchyan)</p>
      <p>
        REST APIs are integral to the functionality of the semantic web, acting as a bridge that enables 
        seamless integration and accessibility of data across diverse systems <a href="#r1">[1]</a>. By utilizing data 
        representation formats like JSON-LD and RDF, REST APIs ensure interoperability by adhering to 
        standardized semantic structures <a href="#r9">[9]</a>. These formats facilitate meaningful and efficient communication 
        between platforms, making them indispensable for managing linked data and knowledge graphs. 
        Additionally, the use of hypermedia principles, such as HATEOAS, expands the potential of the 
        semantic web, enabling dynamic discovery and interaction with interconnected resources .
      </p>
      <p>
        The design of REST APIs for the semantic web faces unique challenges. A key consideration 
        lies in the selection of data formats that balance human readability with machine efficiency <a href="#r1">[1]</a>. 
        Formats like JSON-LD provide a flexible solution, as they are both lightweight and capable of 
        expressing complex semantic relationships. Another critical aspect is ensuring the extensibility 
        of these APIs. As semantic web technologies evolve, APIs must accommodate new requirements while 
        preserving backward compatibility, minimizing disruptions for existing clients <a href="#r3">[3]</a>.
      </p>
      <p>
        Leveraging hypermedia further enhances the semantic web experience by creating dynamic and intuitive 
        interactions. Hypermedia-driven APIs guide clients through available resources and actions, 
        promoting seamless exploration and navigation within the web of linked data <a href="#r9">[9]</a>. This dynamic 
        interaction model not only simplifies resource discovery but also aligns with the REST principle 
        of decoupled client-server relationships, supporting system scalability and adaptability <a href="#r1">[1]</a>.
      </p>
      <p>
        In summary, REST APIs are pivotal in the semantic web for achieving efficient data integration, 
        ensuring interoperability, and enabling intuitive resource navigation <a href="#r9">[9]</a>. By addressing the challenges 
        of extensibility, format selection, and dynamic interaction, REST APIs empower the semantic web to 
        evolve as a powerful platform for interconnected knowledge <a href="#r1">[1]</a>.
      </p>
    </section>
    <section>
      <h2>5. Demonstration</h2>
      <p class="credit">(Quoc Khanh Le)</p>
      <p>
        The purpose of the demonstration project is to create an example REST
        API that is HATEOAS compliant and incorporate into its interface some of
        the best practices discussed earlier.
      </p>
      <p>
        The project is created using .NET Core 8.0 and uses the Odata protocol
        to deliver hypermedia for responses. Figure 6.1 shows the Swagger
        interface when the project is run in debug mode (which enables Swagger
        UI).
      </p>
      <figure>
        <img src="f-06-01-endpoints.png" alt="Endpoints produced by Swagger" />
        <figcaption>Figure 6.1: Endpoints produced by Swagger</figcaption>
      </figure>
      <h3>5.1. The Demo API</h3>
      <p>
        The Swagger interface (figure 6.1) displays multiple endpoints. However,
        theoretically, thanks to HATEOAS, the only endpoint the consumers of the
        API need to know is the root endpoint "/v1", from which others can be
        discovered. This exploration pattern is similar to how a web user can
        theoretically explore an entire website, starting from just the home
        page.
      </p>
      <p>
        When a hypothetical user queries the root endpoint, the following response is returned:
      </p>
      <pre>
HTTP/1.1 200 OK
Connection: close
Content-Type: application/json; odata.metadata=full; odata.streaming=true; charset=utf-8
Date: Thu, 23 Jan 2025 21:37:03 GMT
Server: Kestrel
Transfer-Encoding: chunked
OData-Version: 4.0

{
  "@odata.context": "http://localhost:5139/v1/$metadata",
  "value": [
    {
      "name": "Groups",
      "kind": "EntitySet",
      "url": "Groups"
    },
    {
      "name": "Students",
      "kind": "EntitySet",
      "url": "Students"
    }
  ]
}</pre
      >
      <p>
        This response contains the "@odata.context" link "/v1/$metadata" that points to a
        machine-readable metadata resource describing the Group and Student
        entity set, as well as the links to access these resources. The user can then,
        for example, send a GET request to the "Groups" link to retrieve the
        list of groups:
      </p>
      <pre>
HTTP/1.1 200 OK
Connection: close
Content-Type: application/json; odata.metadata=full; odata.streaming=true; charset=utf-8
Date: Thu, 23 Jan 2025 21:37:59 GMT
Server: Kestrel
Transfer-Encoding: chunked
OData-Version: 4.0

{
  "@odata.context": "http://localhost:5139/v1/$metadata#Groups",
  "value": [
    {
      "@odata.type": "#demo_project.Models.Group",
      "@odata.id": "http://localhost:5139/v1/Groups(1923003579)",
      "@odata.editLink": "Groups(1923003579)",
      "Id@odata.type": "#Int64",
      "Id": 1923003579,
      "Name": "Group 1",
      "Students@odata.associationLink": "http://localhost:5139/v1/Groups(1923003579)/
        Students/$ref",
      "Students@odata.navigationLink": "http://localhost:5139/v1/Groups(1923003579)/
        Students"
    },
    {
      "@odata.type": "#demo_project.Models.Group",
      "@odata.id": "http://localhost:5139/v1/Groups(1923003576)",
      "@odata.editLink": "Groups(1923003576)",
      "Id@odata.type": "#Int64",
      "Id": 1923003576,
      "Name": "Group two",
      "Students@odata.associationLink": "http://localhost:5139/v1/Groups(1923003576)/
        Students/$ref",
      "Students@odata.navigationLink": "http://localhost:5139/v1/Groups(1923003576)/
        Students"
    },
    {
      "@odata.type": "#demo_project.Models.Group",
      "@odata.id": "http://localhost:5139/v1/Groups(1923003551)",
      "@odata.editLink": "Groups(1923003551)",
      "Id@odata.type": "#Int64",
      "Id": 1923003551,
      "Name": "373737",
      "Students@odata.associationLink": "http://localhost:5139/v1/Groups(1923003551)/
        Students/$ref",
      "Students@odata.navigationLink": "http://localhost:5139/v1/Groups(1923003551)/
        Students"
    }
  ]
}</pre
      >
      <p>
        Inside this response, the user can find the same "@odata.context" link
        but with the "Groups" fragment pointing to the Groups specification inside the metadata resource
        representation. The other part of the response, the "value" directory
        contains the list of Groups, each with its own various links: the
        "@odata.id" link that points to the group, the "@odata.editLink" link
        (which is the same link as the "@odata.id" link) that can be used to
        edit or delete the group (using the PUT and DELETE methods
        respectively), the "Students@odata.navigationLink" link used to get the list of students
        belonging to the group, etc. Following that last link, the user can get the
        response:
      </p>
      <pre>
HTTP/1.1 200 OK
Connection: close
Content-Type: application/json; odata.metadata=full; odata.streaming=true; charset=utf-8
Date: Thu, 23 Jan 2025 22:03:09 GMT
Server: Kestrel
Transfer-Encoding: chunked
OData-Version: 4.0

{
  "@odata.context": "http://localhost:5139/v1/$metadata#Students",
  "value": [
    {
      "@odata.type": "#demo_project.Models.Student",
      "@odata.id": "http://localhost:5139/v1/Students(2342506579)",
      "@odata.editLink": "Students(2342506579)",
      "Id@odata.type": "#Int64",
      "Id": 2342506579,
      "FirstName": "Mike",
      "LastName": "Tailor",
      "DateOfBirth@odata.type": "#Date",
      "DateOfBirth": "1992-12-01",
      "Email": "mt@random-tu.de",
      "GroupId@odata.type": "#Int64",
      "GroupId": 1923003579,
      "Group@odata.associationLink": "http://localhost:5139/v1/Students(2342506579)/
        Group/$ref",
      "Group@odata.navigationLink": "http://localhost:5139/v1/Students(2342506579)/
        Group"
    },
    {
      "@odata.type": "#demo_project.Models.Student",
      "@odata.id": "http://localhost:5139/v1/Students(2342506576)",
      "@odata.editLink": "Students(2342506576)",
      "Id@odata.type": "#Int64",
      "Id": 2342506576,
      "FirstName": "James",
      "LastName": "Smith",
      "DateOfBirth@odata.type": "#Date",
      "DateOfBirth": "0502-12-01",
      "Email": "js@random-tu.de",
      "GroupId@odata.type": "#Int64",
      "GroupId": 1923003579,
      "Group@odata.associationLink": "http://localhost:5139/v1/Students(2342506576)/
        Group/$ref",
      "Group@odata.navigationLink": "http://localhost:5139/v1/Students(2342506576)/
        Group"
    },
    {
      "@odata.type": "#demo_project.Models.Student",
      "@odata.id": "http://localhost:5139/v1/Students(2342506582)",
      "@odata.editLink": "Students(2342506582)",
      "Id@odata.type": "#Int64",
      "Id": 2342506582,
      "FirstName": "A",
      "LastName": "B",
      "DateOfBirth@odata.type": "#Date",
      "DateOfBirth": "1999-08-31",
      "Email": "ab@random-tu.de",
      "GroupId@odata.type": "#Int64",
      "GroupId": 1923003579,
      "Group@odata.associationLink": "http://localhost:5139/v1/Students(2342506582)/
        Group/$ref",
      "Group@odata.navigationLink": "http://localhost:5139/v1/Students(2342506582)/
        Group"
    },
    {
      "@odata.type": "#demo_project.Models.Student",
      "@odata.id": "http://localhost:5139/v1/Students(2342506583)",
      "@odata.editLink": "Students(2342506583)",
      "Id@odata.type": "#Int64",
      "Id": 2342506583,
      "FirstName": "Fax",
      "LastName": "Machine",
      "DateOfBirth@odata.type": "#Date",
      "DateOfBirth": "2001-03-21",
      "Email": "fm@random-tu.de",
      "GroupId@odata.type": "#Int64",
      "GroupId": 1923003579,
      "Group@odata.associationLink": "http://localhost:5139/v1/Students(2342506583)/
        Group/$ref",
      "Group@odata.navigationLink": "http://localhost:5139/v1/Students(2342506583)/
        Group"
    }
  ]
}</pre
      >
      <p>
        In this response, for each student, aside from the basic information
        like first and last names, date of birth, etc., there is also a
        set of links similar to those seen in the earlier Group list response. 
        At this point, the user can choose to view only the first Student using the "@odata.id" link and
        get back the following response, which is a sub-section of the previous one:
      </p>
      <pre>
HTTP/1.1 200 OK
Connection: close
Content-Type: application/json; odata.metadata=full; odata.streaming=true; charset=utf-8
Date: Thu, 23 Jan 2025 22:11:03 GMT
Server: Kestrel
Transfer-Encoding: chunked
OData-Version: 4.0

{
  "@odata.context": "http://localhost:5139/v1/$metadata#Students/$entity",
  "@odata.type": "#demo_project.Models.Student",
  "@odata.id": "http://localhost:5139/v1/Students(2342506579)",
  "@odata.editLink": "Students(2342506579)",
  "Id@odata.type": "#Int64",
  "Id": 2342506579,
  "FirstName": "Mike",
  "LastName": "Tailor",
  "DateOfBirth@odata.type": "#Date",
  "DateOfBirth": "1992-12-01",
  "Email": "mt@random-tu.de",
  "GroupId@odata.type": "#Int64",
  "GroupId": 1923003579,
  "Group@odata.associationLink": "http://localhost:5139/v1/Students(2342506579)
    /Group/$ref",
  "Group@odata.navigationLink": "http://localhost:5139/v1/Students(2342506579)
    /Group"
}</pre
      >
      <p>
        As demonstrated above, by just starting from the initial URL, an API
        consumer has the ability to explore the entire structure of the API
        using hypermedia.
      </p>
      <p>
        Please note that in order to receive the API responses with the full hypermedia,
        the following header is needed in each request:
      </p>
      <pre>Accept: application/json;odata.metadata=full</pre>
      <h3>5.2. Design Patterns and Best Practices</h3>
      <p>
        The demo project uses some of the best practices mentioned, such as
        adding a "v1" version identifier to the root URI; using specific,
        plural, self-explanatory nouns for resources (Groups and Students);
        having 2 base URLs for each of them (e.g. "/v1/Groups" and
        "/v1/Groups({groupId})/"); obfuscating resource IDs; and using HTTP
        methods according to the specification.
      </p>
      <p>
        For demonstration purposes, the "/v1/Students({studentId})/Group"
        endpoint returns a detailed error message if the student is not found or
        does not belong to a group. For example, if the student has not joined a
        group, the response would be:
      </p>
      <pre>
HTTP/1.1 404 Not Found
Connection: close
Content-Type: application/json; charset=utf-8
Date: Thu, 23 Jan 2025 22:31:59 GMT
Server: Kestrel
Transfer-Encoding: chunked

{
  "developerMessage": "This student has not joined a group. Check GroupId property to 
    see if the student has joined a group.",
  "userMessage": "This student has not joined a group.",
  "errorCode": "1132",
  "moreInfo": "http://example.com/errors/1132"
}</pre
      >
      <p>
        As part of the Odata protocol, the endpoints also support using
        parameters for selection, ordering, filtering, and paging. For example, the GET
        request to the (unformatted) URL
      </p>
      <pre>
http://localhost:5139/v1/Students?$select=DateOfBirth,FirstName,LastName&orderby=
  DateOfBirth&$filter=LastName eq 'Tailor'</pre
      >
      <p>will return the response:</p>
      <pre>
{
  "@odata.context": "http://localhost:5139/v1/$metadata#Students(DateOfBirth,FirstName,
    LastName)",
  "value": [
    {
      "@odata.type": "#demo_project.Models.Student",
      "@odata.id": "http://localhost:5139/v1/Students(2342506579)",
      "@odata.editLink": "Students(2342506579)",
      "FirstName": "Mike",
      "LastName": "Tailor",
      "DateOfBirth@odata.type": "#Date",
      "DateOfBirth": "1992-12-01"
    },
    {
      "@odata.type": "#demo_project.Models.Student",
      "@odata.id": "http://localhost:5139/v1/Students(2342506577)",
      "@odata.editLink": "Students(2342506577)",
      "FirstName": "Catherin",
      "LastName": "Tailor",
      "DateOfBirth@odata.type": "#Date",
      "DateOfBirth": "2023-12-01"
    }
  ]
}</pre
      >
      <p>
        For demonstration purposes, the "/v1/Students" endpoint supports
        conditional GET with the HTTP header pair
        "Last-Modified"/"If-Modified-Since". For example, if the response for
        the resource request looks like this:
      </p>
      <pre>
HTTP/1.1 200 OK
Connection: close
Content-Type: application/json; odata.metadata=full; odata.streaming=true; charset=utf-8
Date: Thu, 23 Jan 2025 22:33:40 GMT
Server: Kestrel
Last-Modified: Thu, 23 Jan 2025 22:33:47 GMT
Transfer-Encoding: chunked
OData-Version: 4.0

...</pre
      >
      <p>
        The response can then be cached, and the next request for that resource can
        include the additional header:
      </p>
      <pre>If-Modified-Since: Thu, 23 Jan 2025 22:33:47 GMT</pre>
      <p>
        After all that, if the resource is not modified since that timestamp, the server can respond with
        a 304 Not Modified status code, which significantly reduces the volume
        of data needed to be transferred over the network:
      </p>
      <pre>
HTTP/1.1 304 Not Modified
Connection: close
Date: Thu, 23 Jan 2025 22:33:47 GMT
Server: Kestrel</pre
      >
    </section>
    <section>
      <h2>6. Сonclusion</h2>
      <p class="credit">(Georgiy Sinokhchyan)</p>
      <p>
        REST API design has emerged as a fundamental paradigm for building scalable, maintainable, 
        and flexible web services. Its core principles, including statelessness, client-server separation, 
        and uniform interfaces, enable developers to create APIs that are both efficient and adaptable 
        to the evolving needs of modern applications. By adhering to these principles, REST APIs provide 
        a robust framework for seamless communication across distributed systems, fostering independence 
        between components and facilitating evolvability <a href="#r1">[1]</a>.
      </p>
      <p>The success of REST APIs lies not only in their adherence to theoretical principles but also in 
        the application of practical design patterns and best practices. Concepts such as caching, HATEOAS, 
        and effective use of metadata enhance performance, usability, and interoperability, making REST 
        an essential tool for modern web development <a href="#r2">[2]</a>.
      </p>
      <p>
        Despite its strengths, REST API design presents challenges, particularly in areas like security, 
        semantic web integration, and handling the complexities of statelessness. Addressing these challenges 
        requires careful planning, adherence to security guidelines like those from OWASP <a href="#r6">[6]</a>, and leveraging 
        technologies like JSON-LD and RDF to enable semantic interoperability <a href="#r9">[9]</a>.
      </p>
      <p>
        Looking forward, REST APIs will continue to evolve, driven by the demands of microservices 
        architectures, IoT, and other distributed systems. By combining foundational principles with 
        innovative solutions, REST API design will remain a cornerstone of web engineering, enabling 
        the creation of scalable, secure, and future-proof systems.
      </p>
    </section>
    <section class="references">
      <h2>7. References</h2>
      <p class="reference" id="r1">
        [1] R. T. Fielding, “Architectural Styles and the Design of
        Network-based Software Architectures,” Ph.D. dissertation, Dept.
        Information and Computer Science, UC Irvine, California, 2000.
      </p>
      <p class="reference" id="r2">
        [2] M. Masse, REST API design rulebook, CA: O’Reilly Media, Inc, 2011.
      </p>
      <p class="reference" id="r3">
        [3] P. Giessler, M. Gebhart, D. Sarancin, R. Steinegger and S. Abeck,
        "Best Practices for the Design of RESTful Web Services", ICSEA 2015: The
        Tenth International Conference on Software Engineering Advances Best,
        pp. 392-397, 2015.
      </p>
      <p class="reference" id="r4">
        [4] R. T. Fielding. “The reason to make a real REST API is to get
        evolvability.” X. Accessed Dec. 5, 2024. [Online.] Available:
        <a href="https://x.com/fielding/status/376835835670167552"
          >https://x.com/fielding/status/376835835670167552</a
        >
      </p>
      <p class="reference" id="r5">
        [5] B. Mulloy. “Web API Design - Crafting Interfaces that Developers
        Love.” pages.apigee.com. Accessed: Dec. 5, 2024. [Online.] Available:
        <a
          href="https://pages.apigee.com/rs/apigee/images/api-design-ebook-2012-03.pdf"
          >https://pages.apigee.com/rs/apigee/images/api-design-ebook-2012-03.pdf</a
        >
      </p>
      <p class="reference" id="r6">
        [6] OWASP. "Testing for Insecure Direct Object References." owasp.org.
        Accessed: Dec.5, 2024. [Online.] Available:
        <a
          href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authorization_Testing/04-Testing_for_Insecure_Direct_Object_References"
          >https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authorization_Testing/04-Testing_for_Insecure_Direct_Object_References</a
        >
        Testing_for_Insecure_Direct_Object_References
      </p>
      <p class="reference" id="r7">
        [7] S. Vinoski, “RESTful Web Services Development Checklist,” Internet
        Computing, IEEE, vol. 12, no. 6, 2008, pp. 94–96. [Online]. Available:
        <a href="https://ieeexplore.ieee.org/document/4670126"
          >https://ieeexplore.ieee.org/document/4670126</a
        >
      </p>
      <p class="reference" id="r8">
        [8] HTTP Semantics, STD 97 RFC 9110, June 2022. [Online]. Available:
        <a href="https://datatracker.ietf.org/doc/html/rfc9110"
          >https://datatracker.ietf.org/doc/html/rfc9110</a
        >
      </p>
      <p class="reference" id="r9">
        [9] J. Webber, S. Parastatidis, and I. S. Robinson, REST in Practice -
        Hypermedia and Systems Architecture. CA: O’Reilly Media, Inc, 2010.
      </p>
      <p class="reference" id="r10">
        [10] L. Richardson, M. Amundsen and S. Ruby, RESTful Web APIs, CA:
        O’Reilly Media, Inc, 2013.
      </p>
    </section>
  </body>
</html>
