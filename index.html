<!DOCTYPE html>
<html>
  <head>
    <title>
      Proseminar Web Engineering im Sommersemester 2014 - Store in the Cloud or
      not in the Cloud
    </title>
    <link rel="stylesheet" type="text/css" href="main.css" />
    <link
      href="http://fonts.googleapis.com/css?family=Source+Serif+Pro:400,600,700"
      rel="stylesheet"
      type="text/css"
    />
    <link
      href="http://fonts.googleapis.com/css?family=Inconsolata:400,700"
      rel="stylesheet"
      type="text/css"
    />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  </head>
  <body>
    <header>
      <h2>Seminar Web Engineering in Winter semester 2024/2025</h2>
      <h1>REST API Design</h1>
      <h2 class="author">Georgiy Sinokhchyan</h2>
      <h2 class="author">Quoc Khanh Le</h2>
      <h3 class="affiliation">
        Master Web Engineering<br />
        Technische Universität Chemnitz<br />
        Chemnitz, Deutschland
      </h3>
    </header>
    <section>
      <h2>1. Introduction</h2>
      <p>(Georgiy Sinokhchyan)</p>
      <p>
        Over the last two decades, REST (Representational State Transfer) has emerged as a pivotal 
        architectural style for designing web services, largely due to its simplicity, scalability, 
        and flexibility. Introduced by Roy Fielding in his dissertation in 2000 [1], REST has since 
        become the backbone of modern web services, enabling seamless interaction between distributed 
        systems. As the digital ecosystem grows with increasing reliance on mobile devices, microservices,
        and distributed applications, REST APIs have proven to be a reliable framework for managing 
        client-server communications.
      </p>
      <p>
        The flexibility of REST APIs stems from its principles of statelessness, 
        uniform interfaces, and support for hypermedia. These principles, combined with practical 
        design guidelines like those outlined in Masse's REST API Design Rulebook [2], provide developers 
        with the tools to create scalable, secure, and evolvable APIs. However, designing robust 
        REST APIs involves more than adherence to principles—it requires careful consideration 
        of best practices, patterns, and emerging challenges in fields like the semantic web and 
        data security.
      </p>
    </section>
    <section>
      <h2>2. History</h2>
      <p>(Quoc Khanh Le)</p>
      <p>
        In late 1993, the usage of the web expanded beyond researchers to
        include small research groups, clubs, individuals, and institutional
        departments<a href="#r1">[1]</a>. This expansion included homepages
        created by standalone users to share information of their choice, as
        well as homepages maintained by businesses to broadcast their products
        and services to international audiences <a href="#r1">[1]</a>. Roy
        Fielding <a href="#r1">[1]</a> described the situation at the time: "The
        Internet developer community became concerned that the rapid growth in
        the Web’s usage ... would quickly outpace the capacity of the Internet
        infrastructure and lead to a general collapse." After further
        inspection, he discovered a set of key constraints that would naturally
        facilitate the web's scalability <a href="#r2">[2]</a>. In 2000, in his
        Ph.D. dissertation, Fielding named the architectural style built upon
        these constraints "Representational State Transfer" (REST)
        <a href="#r2">[2]</a>.
      </p>
    </section>
    <section>
      <h2>3. REST API Characteristics</h2>
      <h3>3.1. Elements</h3>
      <p>(Quoc Khanh Le)</p>
      <p>
        REST data elements include the resources, which is the target of the
        links inside hypermedia; the resource identifiers, such as URI; the
        resource representations, such as JSON or XML; the representation
        metadata, such as the HTTP "Content-Type" header; the resource metadata,
        such as link relations like source link or alternate link; and the
        control data, such as the HTTP "Accept" header <a href="#r1">[1]</a>.
      </p>
      <p>
        REST connectors include the client and the server connectors, such as
        the library "libwww"; the caches, such as browser cache or cache server;
        the resolvers, such as the DNS look up library "Bind9"; and the tunnels,
        such as those formed by TLS handshakes <a href="#r1">[1]</a>.
      </p>
      <p>
        REST components include the origin servers, such as a Kestrel or IIS
        server; the gateways, such as a reverse proxy; the proxies, such as a
        CERN proxy; and the user agents, such as a web browser or a web crawler
        <a href="#r1">[1]</a>.
      </p>
    </section>
    <section>
      <h3>3.2 Constraints</h3>
      <h4>3.2.1 Client-Server</h4>
      <p>(Georgiy Sinokhchyan)</p>
      <p>
        The client-server paradigm is one of the fundamental principles of REST. 
        By separating the user interface (client) from data storage and processing (server), 
        REST enables modularity and independent scalability [1]. This separation ensures that 
        clients can evolve without affecting servers and vice versa, fostering flexibility in 
        development and maintenance.
      <ol>
        <li>Decoupled Evolution: Clients and servers can independently upgrade or change without breaking compatibility.</li>
        <li>Scalability: Multiple clients can interact with the server concurrently.</li>
        <li>Security: By centralizing data storage, servers can enforce consistent security protocols.</li>
      </ol>
      </p>
    </section>
    <section>
      <h4>3.2.2 Stateless</h4>
      <p>(Georgiy Sinokhchyan)</p>
      <p>
        Statelessness, another cornerstone of REST, requires each request from the client 
        to contain all necessary information for processing [1]. This design eliminates the need 
        for the server to maintain session state, simplifying server-side operations and improving 
        scalability.
      </p>
      <p>
        However, implementing statelessness comes with challenges. 
        While it reduces server load and enhances fault tolerance, developers must ensure 
        that each request carries sufficient metadata for processing. 
        For instance, secure session tokens are often used to handle authentication, 
        aligning with OWASP guidelines for web application security [6].
      </p>
      <p>
        Advantages of Statelessness:
        <ol>
          <li>Fault Tolerance: Servers can recover from failures without losing session data.</li>
          <li>Scalability: Stateless APIs distribute load evenly across server clusters.</li>
          <li>Simplified Maintenance: Stateless systems are easier to debug and update.</li>
        </ol>
      </p>
    </section>
    <section>
      <h4>3.2.3 Cache</h4>
      <p>(Georgiy Sinokhchyan)</p>
      <p>
        The uniform interface principle ensures consistency in how clients interact with resources [1]. REST achieves this through:
      </p>
      <p>
        The key elements of a uniform interface are:
        <ol>
          <li>Resource Identification: Each resource is identified by a unique URI.</li>
          <li>HTTP Methods: Operations like GET, POST, PUT, and DELETE are standardized.</li>
          <li>Self-Descriptive Messages: Requests and responses include sufficient metadata (e.g., content type).</li>
          <li>Hypermedia as the Engine of Application State (HATEOAS): Links guide clients to related resources dynamically.</li>
        </ol>
      </p>
      <p>
        According to Fielding, a uniform interface enhances evolvability by decoupling client and server implementations [4]. For example, APIs designed for e-commerce platforms utilize URIs like /products/{id} to access product data. Such APIs provide predictable and extensible interactions, minimizing developer overhead.
      </p>
    </section>
    <section>
      <h4>3.2.4 Uniform interface</h4>
      <p>(Quoc Khanh Le)</p>
      <p>
        Uniform interface is the major constraint that set the REST API
        architectural style apart from other network-based API styles
        <a href="#r1">[1]</a>. It requires that the outward facing interface of
        a service remains general, which promotes independence between the
        interface and the implementation of a service <a href="#r1">[1]</a>.
        This independence allows for decoupled evolvability, but has the
        drawback of introducing loss of efficiency because the information
        transferred needs to be in the general, standardized form and not one
        optimized for the application's needs <a href="#r1">[1]</a>. There are
        four sub constraints that need to be fulfilled to satisfy the uniform
        interface constraint: identification of resources, manipulation of
        resources through representations, self-descriptive messages, and hyper
        media as the engine of application state <a href="#r1">[1]</a>.
      </p>
      <p>
        Resources are defined by Roy Fielding <a href="#r1">[1]</a> as "any
        information that can be named": a document/ an image, a time-dependent
        service, a collection of other resources, an object, etc. A resource, in
        this sense, is a pointer to a set of entities, and not any specific
        entity at any point in time <a href="#r1">[1]</a>.
      </p>
      <h5>3.2.4.1 Identification of resources</h5>
      <p>(Quoc Khanh Le)</p>
      <p>
        A resource identifier uniquely identifies a resource in an interaction
        between components, and can be used in combination with REST connectors
        to manipulate the value of the resource, regardless of the backing
        implementation of this manipulation <a href="#r1">[1]</a>.
      </p>
      <h5>3.2.4.2 Manipulation of resources through representations</h5>
      <p>(Quoc Khanh Le)</p>
      <p>
        The manipulation of a resource is done through a representation, which
        is a byte sequence and the metadata that describes those bytes
        <a href="#r1">[1]</a>. A representation represents the contemporary or
        targeted state of a resource when being transferred between components
        <a href="#r1">[1]</a>
      </p>
      <h5>3.2.4.3 Self-descriptive messages</h5>
      <p>(Quoc Khanh Le)</p>
      <p>
        The self-descriptive messages constraint requires that no states are
        transferred between requests, in other words, the messages should
        contain all of the required information to process it, including the
        semantics indicated through media types and standard methods,
        cacheability communicated in responses
        <a href="#r1">[1]</a>.
      </p>
      <h5>3.2.4.4 Hypermedia as the engine of application state (HATEOAS)</h5>
      <p>(Quoc Khanh Le)</p>
      <p>
        The core idea of HATEOAS is that the client does not need to have prior
        knowledge of the APIs structure to interact with it. To achieve this,
        the responses need to contain links to other resources to guide the
        client to other actions based on the current application state.
      </p>
    </section>
    <section>
      <h4>3.2.5 Layered system</h4>
      <p>(Quoc Khanh Le)</p>
      <p>
        The layered system constraint requires the components to only know of
        their immediate neighboring components, which promotes inter-layer
        independence and allows layers to be added to or removed from the
        architecture without greatly affecting the existing infrastructure
        <a href="#r1">[1]</a>.
      </p>
      <p>
        This constraint enables the use of firewalls, load balancing and caching
        components to improve the security, scalability and performance of the
        system <a href="#r1">[1]</a>. It also allows layers to act as
        intermediaries between legacy clients or services and newer components
        or clients <a href="#r1">[1]</a>.
      </p>
      <p>
        However, the addition of layers can induce a general increase in latency
        and overhead in the request-response chains
        <a href="#r1">[1]</a>.
      </p>
    </section>
    <section>
      <h4>3.2.6 Code on demand</h4>
      <p>(Quoc Khanh Le)</p>
      <p>
        The code on demand constraint allows the server to send executable code
        to the clients, effectively enabling the extension of client
        functionality after deployment <a href="#r1">[1]</a>. This capability,
        nonetheless, reduces the visibility of the interaction, as it can be
        challenging for an inspector to fully understand all of the effects that
        executing the code sent from the server will have <a href="#r1">[1]</a>.
      </p>
      <p>
        This constraint is the only optional constraint in REST because APIs
        following the REST architectural style can choose to implement it or not
        (or restricting its availability to a range of clients) and therefore
        only reap the benefits and suffer the drawbacks accordingly
        <a href="#r1">[1]</a>.
      </p>
    </section>
    <section>
      <h2>4. Design patterns and best practices</h2>
      <h3>4.1 No versioning</h3>
      <p>(Quoc Khanh Le)</p>
      <p>*needs further modification</p>
      <p>
        Thanks to hypermedia, REST api do not need to be versioned
        <a href="#3">[3]</a>.
      </p>
    </section>
    <section>
      <h3>4.2 Description of resources</h3>
      <p>
        Nouns should be used for resource names <a href="#3">[3]</a>,
        <a href="#5">[5]</a>, as they represent resources to be accessed and
        manipulated, rather than actions to be performed. Instead, in the
        context of HTTP APIs, HTTP verbs should be used to indicate the
        intentions of the clients <a href="#5">[5]</a>.
      </p>
      <p>
        To ensure consistency and predictability, plural and singular forms
        should not be mixed when naming resources <a href="#3">[3]</a>
      </p>
      <p>
        Adhering to JavaScript naming conventions is recommended
        <a href="#5">[5]</a> since JSON is currently the most used data format
        for transferring data between clients and servers <a href="#3">[3]</a>.
      </p>
      <p>
        Names of resources should be specific to aid client developers in API
        comprehension and utilisation <a href="#5">[5]</a>. For example,
        descriptive endpoints such as /blogs, /videos, /news, etc. are
        preferable to generic one such as /items <a href="#5">[5]</a>.
      </p>
    </section>
    <section>
      <h3>4.3 Identification of resources</h3>
      <p>
        URI should be self explanatory to the best of its ability
        <a href="#5">[5]</a>. For every resource, there should be generally 2
        base URLs: one for accessing/manipulating the list and the other for
        accessing/manipulating a specific item in the list (for example, /books
        and /books/393) <a href="#5">[5]</a>.
      </p>
      <p>
        In case there are no security measures in place, the URIs should not
        reference the resource directly
        <a href="#3">[3]</a>, <a href="#6">[6]</a>.
      </p>
    </section>
    <section>
      <h3>4.4 Error handling</h3>
      <p>
        The number of HTTP status codes produced by the API should be limited to
        8 or lower to alleviate client developers' cognitive load and allow them
        to focus on the implementation of functionalities
        <a href="#5">[5]</a>. The use of HTTP status codes also should align
        with the guidelines outlined in the HTTP specification
        <a href="#7">[7]</a>, <a href="#8">[8]</a>.
      </p>
      <p>
        Error messages returned from the API should be verbose
        <a href="#5">[5]</a>. B. Mulloy. <a href="#5">[5]</a> recommends
        returning a message for the developer detailing how to fix the error, a
        message for the end user to be displayed, an application error code for
        code handling and a link to further explanation of the error. For
        example, the following response can be returned when a device with an
        invalid device ID is requested by a client:
      </p>
      <pre>
  {
    "developerMessage" : "The device requested cannot be found, please
      make sure the device ID is correct and the user is authorized to
      access it.", 
    "userMessage":"Device not found", 
    "errorCode" : "device-not-found", 
    "moreInfo": "http://example.com/errors/device-not-found"
  }</pre
      >
    </section>
    <section>
      <h3>4.5 Parameter usage</h3>
      <p>
        Parameters should be used for filtering, sorting, selecting and paging
        of resources <a href="#3">[3]</a>. Followed are some examples:
      </p>
      <pre>

  <b>Filtering:</b> GET /devices?filter=(type=key-pad)

  <b>Sorting:</b> GET /devices?sort=type

  <b>Selecting:</b> GET /devices?fields=id,name,type,status

  <b>Paging:</b> GET /devices?offset=20&limit=10
  </pre
      >
    </section>
    <section>
      <h3>4.6 Interaction with resources</h3>
      <p>
        HTTP methods should conform with their semantics as defined by the HTTP
        specification <a href="#5">[5]</a>, <a href="#8">[8]</a>. Generally,
        POST, GET, PUT, and DELETE should be used to perform the CRUD actions
        (Create, Read, Update, Delete) in that respective order
        <a href="#8">[8]</a>.
      </p>
      <p>
        For any resource, if the list of methods allowed is not made available
        to the consumers, the HTTP OPTIONS verb should be supported to avoid the
        transmission of high-volume data when a client tries to use an
        unsupported verb <a href="#3">[3]</a>.
      </p>
      <p>
        To leverage caching, conditional GET should be implemented
        <a href="#7">[7]</a>. HTTP has 2 built-in mechanisms for this purpose:
        the header pairs "Last-Modified"/"If-Modified-Since" and
        "Etag"/"If-None-Match", with the latter avoiding the "one-second window"
        change problem of the former <a href="#7">[7]</a>. Specifically, due to
        the one-second granularity of the "If-Modified-Since" header, when 2
        changes occur within one second, the clients that have cached the first
        representation cannot detect the second change <a href="#7">[7]</a>.
      </p>
    </section>
    <section>
      <h3>4.7 Support mime types</h3>
      <p>
        B. Mulloy. <a href="#5">[5]</a> suggested that at least 2 MIME types
        should be supported, especially when receiving data. Among them, the
        default representation format should be JSON because it's more universal
        and less verbose than XML <a href="#5">[5]</a>.
      </p>
      <p>
        To accommodate hypermedia, existing MIME types such as Collection+JSON
        or HAL+XML are recommended <a href="#3">[3]</a>.
      </p>
      <p>
        The API should also support content negotiation, typically through the
        use of the HTTP header "Accept" to indicate the MIME types and,
        optionally, the preference or weight of each option
        <a href="#3">[3]</a>.
      </p>
    </section>
    <section>
      <h2>5. REST API's in semantic web domain</h2>
      <p>(Georgiy Sinokhchyan)</p>
      <p>
        REST APIs have become integral to the semantic web, enabling data integration and accessibility. By leveraging formats like JSON-LD and RDF, REST APIs support interoperability across diverse systems [9]. The use of hypermedia (HATEOAS) further enhances the semantic web by enabling dynamic discovery of linked resources [3].
      </p>
      <p>
        Key Challenges in Semantic Web API Design:
      </p>
      <p>
       <ol>
         <li>Data Standards: Adopting formats that balance human readability and machine processing.</li>
         <li>Extensibility: Designing APIs to accommodate future requirements without disrupting existing clients.</li>
         <li>Dynamic Interactions: Utilizing hypermedia for seamless client navigation and resource exploration [9].</li>
       </ol>
      </p>    
    </section>
    <section>
      <h2>6. Demo</h2>
      <p>(Quoc Khanh Le)</p>
    </section>
    <section class="references">
      <h2>7. References</h2>
      <p class="reference" id="r1">
        [1] R. T. Fielding, “Architectural Styles and the Design of
        Network-based Software Architectures,” Ph.D. dissertation, Dept.
        Information and Computer Science, UC Irvine, California, 2000.
      </p>
      <p class="reference" id="r2">
        [2] M. Masse, REST API design rulebook, CA: O’Reilly Media, Inc, 2011.
      </p>
      <p class="reference" id="r3">
        [3] P. Giessler, M. Gebhart, D. Sarancin, R. Steinegger and S. Abeck,
        "Best Practices for the Design of RESTful Web Services", ICSEA 2015: The
        Tenth International Conference on Software Engineering Advances Best,
        pp. 392-397, 2015.
      </p>
      <p class="reference" id="r4">
        [4] R. T. Fielding. “The reason to make a real REST API is to get
        evolvability.” X. Accessed Dec. 5, 2024. [Online.] Available:
        <a href="https://x.com/fielding/status/376835835670167552"
          >https://x.com/fielding/status/376835835670167552</a
        >
      </p>
      <p class="reference" id="r5">
        [5] B. Mulloy. “Web API Design - Crafting Interfaces that Developers
        Love.” pages.apigee.com. Accessed: Dec. 5, 2024. [Online.] Available:
        <a
          href="https://pages.apigee.com/rs/apigee/images/api-design-ebook-2012-03.pdf"
          >https://pages.apigee.com/rs/apigee/images/api-design-ebook-2012-03.pdf</a
        >
      </p>
      <p class="reference" id="r6">
        [6] OWASP. "Testing for Insecure Direct Object References." owasp.org.
        Accessed: Dec.5, 2024. [Online.] Available:
        <a
          href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authorization_Testing/04-Testing_for_Insecure_Direct_Object_References"
          >https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/05-Authorization_Testing/04-Testing_for_Insecure_Direct_Object_References</a
        >
        Testing_for_Insecure_Direct_Object_References
      </p>
      <p class="reference" id="r7">
        [7] S. Vinoski, “RESTful Web Services Development Checklist,” Internet
        Computing, IEEE, vol. 12, no. 6, 2008, pp. 94–96. [Online]. Available:
        <a href="https://ieeexplore.ieee.org/document/4670126"
          >https://ieeexplore.ieee.org/document/4670126</a
        >
      </p>
      <p class="reference" id="r8">
        [8] HTTP Semantics, STD 97 RFC 9110, June 2022. [Online]. Available:
        <a href="https://datatracker.ietf.org/doc/html/rfc9110"
          >https://datatracker.ietf.org/doc/html/rfc9110</a
        >
      </p>
      <p class="reference" id="r9">
        [9] J. Webber, S. Parastatidis, and I. S. Robinson, REST in Practice -
        Hypermedia and Systems Architecture. CA: O’Reilly Media, Inc, 2010.
      </p>
    </section>
  </body>
</html>
